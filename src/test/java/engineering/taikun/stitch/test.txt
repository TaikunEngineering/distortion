package engineering.taikun.database.distortion.structures;

import engineering.taikun.database.distortion.serialization.SerializationUtil;
import engineering.taikun.database.distortion.serialization.api.ByteArray;
import engineering.taikun.database.distortion.store.api.KV;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

/**
 * <p>An implementation of a random-access {@link List} and a {@link Deque} using a backing {@link KV}</p>
 *
 * <p><tt>null</tt> values are allowed</p>
 *
 * <p>It operates by using an int-big keyspace and using head and tail 'pointers'.</p>
 *
 * <p>Since it's backed by a KV, it has O(1) accesses, while being able to crawl left and right without casdin awerkj</p>
 *
 * <p>Note: While this class is a proper {@link Deque}, the {@link #equals} method only matches {@link List}s</p>
 *
 * @param <T> The element type of the list
 * @param <BA> The type of the {@link ByteArray} implementation
 */
@SuppressWarnings({ "unchecked", "ConstantConditions" })
public class DList<T, BA extends ByteArray<BA>> extends AbstractList<T> implements DStructure, Deque<T>, RandomAccess {

	public final int MAX_HEIGHT;

	public final KV<BA> kv;
	public final SerializationUtil<BA> util;

	// named 'start' and 'end' which are a little clearer than 'head' and 'tail' imo
	final BA START_KEY;
	final BA END_KEY;
	final BA META_KEY;

	public DList(final KV<BA> kv, final SerializationUtil<BA> util, final boolean initialize) {
		this.MAX_HEIGHT = Integer.MAX_VALUE;
		this.kv = kv;
		this.util = util;

		this.START_KEY = util.new IntUnion(-2).getBytes();
		this.END_KEY = util.new IntUnion(-3).getBytes();
		this.META_KEY = util.new IntUnion(-4).getBytes();

		if (initialize) {
			kv.write(this.START_KEY, util.new IntUnion(0).getBytes());
			kv.write(this.END_KEY, util.new IntUnion(0).getBytes());
		}
	}

	//$ if (DEBUG) {
	public DList(
			final KV<BA> kv, final SerializationUtil<BA> util, final int MAX_HEIGHT
	) {
		this.MAX_HEIGHT = MAX_HEIGHT;
		this.kv = kv;
		this.util = util;

		this.START_KEY = util.new IntUnion(-2).getBytes();
		this.END_KEY = util.new IntUnion(-3).getBytes();
		this.META_KEY = util.new IntUnion(-4).getBytes();

		kv.write(this.START_KEY, util.new IntUnion(0).getBytes());
		kv.write(this.END_KEY, util.new IntUnion(0).getBytes());
	}
	//$ }

	@Override
	public @NotNull String getMetadata() {
		final BA fetch = this.kv.read(this.META_KEY);

		if (fetch == null) {
			return "";
		}

		return (String) this.util.unpack(null, fetch);
	}

	@Override
	public void setMetadata(final @NotNull String metadata) {
		this.kv.write(this.META_KEY, this.util.serialize(metadata));
	}

	@Override
	public void destroy() {
		clear();
		this.kv.delete(this.START_KEY);
		this.kv.delete(this.END_KEY);
		this.kv.delete(this.META_KEY);
	}

	@Override
	public int size() {
		final int start = this.util.new IntUnion(this.kv.read(this.START_KEY)).getInt();
		final int end = this.util.new IntUnion(this.kv.read(this.END_KEY)).getInt();

		//      /- we don't allow end==start because it would be ambiguous if the list was empty or full
		if (end < start) {
			return (this.MAX_HEIGHT - start) + end;
		} else {
			return end - start;
		}
	}

	@Override
	public boolean add(final T t) {

		final int end = this.util.new IntUnion(this.kv.read(this.END_KEY)).getInt();

		if (end == this.MAX_HEIGHT) {

			final BA zero_ba = this.util.new IntUnion(0).getBytes();

			if (this.kv.read(zero_ba) != null) {
				throw new IllegalStateException("List capacity exceeded");
			}

			this.util.store(this.kv, zero_ba, t);

			this.kv.write(this.END_KEY, this.util.new IntUnion(1).getBytes());

			this.modCount++;

			return true;
		}

		final BA end_ba = this.util.new IntUnion(end).getBytes();

		if (this.kv.read(end_ba) != null) {
			throw new IllegalStateException("List capacity exceeded");
		}

		this.util.store(this.kv, end_ba, t);

		this.kv.write(this.END_KEY, this.util.new IntUnion(end + 1).getBytes());

		this.modCount++;

		return true;
	}

	@Override
	public boolean addAll(final int index, final Collection<? extends T> c) {
		if (index < 0)
			throw new IndexOutOfBoundsException();

		if (c.isEmpty()) {
			if (index > size()) {
				throw new IndexOutOfBoundsException();
			}
			return false;
		}

		final int c_size = c.size();

		if (index == 0) {
			// special case for push

			final int start = this.util.new IntUnion(this.kv.read(this.START_KEY)).getInt();
			final int newstart_test = start - c_size;

			//                /- 0 is an allowable starting point
			if (newstart_test < 0) {

				final int newstart = this.MAX_HEIGHT - (c_size - start);

				if (this.kv.read(this.util.new IntUnion(newstart).getBytes()) != null) {
					throw new IllegalStateException("List capacity exceeded");
				}

				int i = newstart;
				for (final T element : c) {
					if (i == this.MAX_HEIGHT)
						i = 0;

					this.util.store(this.kv, this.util.new IntUnion(i++).getBytes(), element);
				}

				this.kv.write(this.START_KEY, this.util.new IntUnion(newstart).getBytes());

				this.modCount++;

				return true;
			}

			//$ if (DEBUG) {
			if (newstart_test == 0) {
				Thread.currentThread(); // no-op for coverage tracking
			} else {
				Thread.currentThread(); // no-op for coverage tracking
			}
			//$ }

			final int newstart = newstart_test;

			if (this.kv.read(this.util.new IntUnion(newstart).getBytes()) != null) {
				throw new IllegalStateException("List capacity exceeded");
			}

			int i = newstart;
			for (final T element : c) {
				this.util.store(this.kv, this.util.new IntUnion(i++).getBytes(), element);
			}

			this.kv.write(this.START_KEY, this.util.new IntUnion(newstart).getBytes());

			this.modCount++;

			return true;
		}

		final int start = this.util.new IntUnion(this.kv.read(this.START_KEY)).getInt();
		final int end = this.util.new IntUnion(this.kv.read(this.END_KEY)).getInt();

		// paid the cost of reading start and end, lower impact than determining/testing new high point
		final int my_size = size();

		if ((long) my_size + c_size > (long) this.MAX_HEIGHT) {
			throw new IllegalStateException("List capacity exceeded");
		}

		if (index > my_size) {
			throw new IndexOutOfBoundsException();
		}

		int i = end - 1;
		Integer newend = null;
		while (true) {
			if ( //                            /- this tests when we 'go past', on the edge, we need to test for 0, not MAX
					i == ((long) start + index - 1 >= this.MAX_HEIGHT
							? (start + index - this.MAX_HEIGHT - 1)
							: (start + index - 1)
					)
			) {
				//$ if (DEBUG) {
				if ((long) start + index - 1 == this.MAX_HEIGHT) {
					Thread.currentThread(); // no-op for coverage tracking
				} else {
					Thread.currentThread(); // no-op for coverage tracking
				}
				//$ }

				if (newend == null) {
					// triggered when adding to the end
					//                      /- MAX is an allowable end
					if ((long) end + c_size > (long) this.MAX_HEIGHT) {
						newend = (int) ((long) end + c_size - this.MAX_HEIGHT);
					} else {
						//$ if (DEBUG) {
						if ((long) end + c_size == (long) this.MAX_HEIGHT) {
							Thread.currentThread(); // no-op for coverage tracking
						} else {
							Thread.currentThread(); // no-op for coverage tracking
						}
						//$ }

						newend = end + c_size;
					}
				}
				break;
			}

			final BA tempkey = this.util.new IntUnion(i).getBytes();
			T temp = (T) this.util.unpack(this.kv, this.kv.read(tempkey));
			if (temp instanceof DStructure) {
				temp = (T) SerializationUtil.convertAndDestroy((DStructure) temp);
			}
			this.kv.delete(tempkey);

			//                    /- can't store at MAX, store at 0
			if ((long) i + c_size >= (long) this.MAX_HEIGHT) {

				//$ if (DEBUG) {
				if ((long) i + c_size == (long) this.MAX_HEIGHT) {
					Thread.currentThread(); // no-op for coverage tracking
				} else {
					Thread.currentThread(); // no-op for coverage tracking
				}
				//$ }

				this.util.store(this.kv, this.util.new IntUnion((int) ((long) i + c_size - this.MAX_HEIGHT)).getBytes(), temp);

			} else {

				this.util.store(this.kv, this.util.new IntUnion(i + c_size).getBytes(), temp);

			}

			// sets newend upon first iteration
			if (newend == null) {
				//                    /- adds 1, MAX+1 is not an allowable end
				if ((long) i + c_size >= (long) this.MAX_HEIGHT) {
					//$ if (DEBUG) {
					if ((long) i + c_size == (long) this.MAX_HEIGHT) {
						Thread.currentThread(); // no-op for coverage tracking
					} else {
						Thread.currentThread(); // no-op for coverage tracking
					}
					//$ }

					newend = (int) ((long) i + c_size - this.MAX_HEIGHT + 1);
				} else {
					newend = i + 1 + c_size;
				}
			}

			if (i == 0) {
				i = this.MAX_HEIGHT - 1;
			} else {
				i--;
			}
		}

		//                       /- can't store at MAX, store at 0
		i = (long) start + index >= (long) this.MAX_HEIGHT
				? start + index - this.MAX_HEIGHT
				: start + index;

		//$ if (DEBUG) {
		if ((long) start + index == (long) this.MAX_HEIGHT) {
			Thread.currentThread(); // no-op for coverage tracking
		} else {
			Thread.currentThread(); // no-op for coverage tracking
		}
		//$ }

		for (final T element : c) {

			this.util.store(this.kv, this.util.new IntUnion(i).getBytes(), element);

			if (i == this.MAX_HEIGHT - 1) {
				i = 0;
			} else {
				i++;
			}
		}

		this.kv.write(this.END_KEY, this.util.new IntUnion(newend).getBytes());

		this.modCount++;

		return true;
	}

	@Override
	public T get(final int index) {
		if (index < 0)
			throw new IndexOutOfBoundsException();

		final int start = this.util.new IntUnion(this.kv.read(this.START_KEY)).getInt();
		//                                     /- nothing to read at MAX
		final BA key_ba = (long) start + index >= (long) this.MAX_HEIGHT
				? this.util.new IntUnion((int) ((long) start + index - this.MAX_HEIGHT)).getBytes()
				: this.util.new IntUnion(start + index).getBytes();

		//$ if (DEBUG) {
		if ((long) start + index == (long) this.MAX_HEIGHT) {
			Thread.currentThread(); // no-op for coverage tracking
		} else {
			Thread.currentThread(); // no-op for coverage tracking
		}
		//$ }

		final BA read_bytes = this.kv.read(key_ba);

		if (read_bytes == null) {
			throw new IndexOutOfBoundsException();
		}

		final T temp = (T) this.util.unpack(this.kv, read_bytes);

		if (temp instanceof DStructure) {
			return (T) SerializationUtil.convert((DStructure) temp);
		}

		return temp;
	}

	@Override
	public T getLast() {

		final int end = this.util.new IntUnion(this.kv.read(this.END_KEY)).getInt();

		final T temp = (T) this.util.unpack(this.kv, this.kv.read(this.util.new IntUnion(end - 1).getBytes()));

		if (temp instanceof DStructure) {
			return (T) SerializationUtil.convert((DStructure) temp);
		}

		return temp;
	}

	@Override
	public T set(final int index, final T element) {
		if (index < 0)
			throw new IndexOutOfBoundsException();

		final int start = this.util.new IntUnion(this.kv.read(this.START_KEY)).getInt();
		//                                     /- nothing to set at MAX
		final BA key_ba = (long) start + index >= (long) this.MAX_HEIGHT
				? this.util.new IntUnion((int) ((long) start + index - this.MAX_HEIGHT)).getBytes()
				: this.util.new IntUnion(start + index).getBytes();

		//$ if (DEBUG) {
		if ((long) start + index == (long) this.MAX_HEIGHT) {
			Thread.currentThread(); // no-op for coverage tracking
		} else {
			Thread.currentThread(); // no-op for coverage tracking
		}
		//$ }

		final BA read_bytes = this.kv.read(key_ba);

		if (read_bytes == null) {
			throw new IndexOutOfBoundsException();
		}

		T temp = (T) this.util.unpack(this.kv, read_bytes);

		if (temp instanceof DStructure) {
			temp = (T) SerializationUtil.convertAndDestroy((DStructure) temp);
		}

		this.util.store(this.kv, key_ba, element);

		return temp;
	}

	@Override
	public void add(final int index, final T element) {
		addAll(index, Collections.singleton(element));
	}

	@Override
	public T remove(final int index) {
		if (index < 0) {
			throw new IndexOutOfBoundsException();
		}

		if (index == 0) {
			// special case

			final int start = this.util.new IntUnion(this.kv.read(this.START_KEY)).getInt();
			final BA returnkey = this.util.new IntUnion(start).getBytes();
			final BA read_bytes = this.kv.read(returnkey);

			if (read_bytes == null) {
				throw new IndexOutOfBoundsException();
			}

			T toreturn = (T) this.util.unpack(this.kv, read_bytes);
			if (toreturn instanceof DStructure) {
				toreturn = (T) SerializationUtil.convertAndDestroy((DStructure) toreturn);
			}
			this.kv.delete(returnkey);

			if (start == this.MAX_HEIGHT - 1) {
				this.kv.write(this.START_KEY, this.util.new IntUnion(0).getBytes());
			} else {
				this.kv.write(this.START_KEY, this.util.new IntUnion(start + 1).getBytes());
			}

			this.modCount++;

			return toreturn;
		}

		final int start = this.util.new IntUnion(this.kv.read(this.START_KEY)).getInt();
		final int end = this.util.new IntUnion(this.kv.read(this.END_KEY)).getInt();

		T toreturn;
		//                       /- nothing to delete at MAX
		if ((long) start + index >= (long) this.MAX_HEIGHT) {

			//$ if (DEBUG) {
			if ((long) start + index == (long) this.MAX_HEIGHT) {
				Thread.currentThread(); // no-op for coverage tracking
			} else {
				Thread.currentThread(); // no-op for coverage tracking
			}
			//$ }

			final BA returnkey = this.util.new IntUnion((int) ((long) start + index - this.MAX_HEIGHT)).getBytes();
			final BA read_bytes = this.kv.read(returnkey);

			if (read_bytes == null) {
				throw new IndexOutOfBoundsException();
			}

			toreturn = (T) this.util.unpack(this.kv, read_bytes);
			if (toreturn instanceof DStructure) {
				toreturn = (T) SerializationUtil.convertAndDestroy((DStructure) toreturn);
			}
			this.kv.delete(returnkey);

			if (end == 1) {

				this.kv.write(this.END_KEY, this.util.new IntUnion(this.MAX_HEIGHT).getBytes());

			} else {

				for (int i = (int) ((long) start + index - this.MAX_HEIGHT); i < end - 1; i++) {
					final BA temp_key = this.util.new IntUnion(i + 1).getBytes();
					T temp_value = (T) this.util.unpack(this.kv, this.kv.read(temp_key));
					if (temp_value instanceof DStructure) {
						temp_value = (T) SerializationUtil.convertAndDestroy((DStructure) temp_value);
					}
					this.kv.delete(temp_key);
					this.util.store(this.kv, this.util.new IntUnion(i).getBytes(), temp_value);
				}

				this.kv.write(this.END_KEY, this.util.new IntUnion(end - 1).getBytes());

			}

		} else {

			final BA returnkey = this.util.new IntUnion(start + index).getBytes();
			final BA read_bytes = this.kv.read(returnkey);

			if (read_bytes == null) {
				throw new IndexOutOfBoundsException();
			}

			toreturn = (T) this.util.unpack(this.kv, read_bytes);
			if (toreturn instanceof DStructure) {
				toreturn = (T) SerializationUtil.convertAndDestroy((DStructure) toreturn);
			}
			this.kv.delete(returnkey);

			if (end < start) {

				for (int i = start + index; i < this.MAX_HEIGHT - 1; i++) {
					final BA temp_key = this.util.new IntUnion(i + 1).getBytes();
					T temp_value = (T) this.util.unpack(this.kv, this.kv.read(temp_key));
					if (temp_value instanceof DStructure) {
						temp_value = (T) SerializationUtil.convertAndDestroy((DStructure) temp_value);
					}
					this.kv.delete(temp_key);
					this.util.store(this.kv, this.util.new IntUnion(i).getBytes(), temp_value);
				}

				if (end >= 1) {
					final BA temp_key = this.util.new IntUnion(0).getBytes();
					T temp_value = (T) this.util.unpack(this.kv, this.kv.read(temp_key));
					if (temp_value instanceof DStructure) {
						temp_value = (T) SerializationUtil.convertAndDestroy((DStructure) temp_value);
					}
					this.kv.delete(temp_key);
					this.util.store(this.kv, this.util.new IntUnion(this.MAX_HEIGHT - 1).getBytes(), temp_value);
				}

				for (int i = 0; i < end - 1; i++) {
					final BA temp_key = this.util.new IntUnion(i + 1).getBytes();
					T temp_value = (T) this.util.unpack(this.kv, this.kv.read(temp_key));
					if (temp_value instanceof DStructure) {
						temp_value = (T) SerializationUtil.convertAndDestroy((DStructure) temp_value);
					}
					this.kv.delete(temp_key);
					this.util.store(this.kv, this.util.new IntUnion(i).getBytes(), temp_value);
				}

				if (end == 1) {
					this.kv.write(this.END_KEY, this.util.new IntUnion(this.MAX_HEIGHT).getBytes());
				} else {
					this.kv.write(this.END_KEY, this.util.new IntUnion(end - 1).getBytes());
				}

			} else {

				for (int i = start + index; i < end - 1; i++) {
					final BA temp_key = this.util.new IntUnion(i + 1).getBytes();
					T temp_value = (T) this.util.unpack(this.kv, this.kv.read(temp_key));
					if (temp_value instanceof DStructure) {
						temp_value = (T) SerializationUtil.convertAndDestroy((DStructure) temp_value);
					}
					this.kv.delete(temp_key);
					this.util.store(this.kv, this.util.new IntUnion(i).getBytes(), temp_value);
				}

				this.kv.write(this.END_KEY, this.util.new IntUnion(end - 1).getBytes());

			}

		}

		this.modCount++;

		return toreturn;
	}

	@Override
	public T removeLast() {

		final int end = this.util.new IntUnion(this.kv.read(this.END_KEY)).getInt();
		final BA returnkey = this.util.new IntUnion(end - 1).getBytes();
		final BA read_bytes = this.kv.read(returnkey);

		if (read_bytes == null) {
			throw new IndexOutOfBoundsException();
		}

		T toreturn = (T) this.util.unpack(this.kv, read_bytes);
		if (toreturn instanceof DStructure) {
			toreturn = (T) SerializationUtil.convertAndDestroy((DStructure) toreturn);
		}
		this.kv.delete(returnkey);

		if (end == 1) {
			this.kv.write(this.END_KEY, this.util.new IntUnion(this.MAX_HEIGHT).getBytes());
		} else {
			this.kv.write(this.END_KEY, this.util.new IntUnion(end - 1).getBytes());
		}

		return toreturn;
	}

	/*
	 * All the other shit for Deque<T>
	 */

	@Override @NotNull public Iterator<T> descendingIterator() {
		return new DescendingIterator();
	}

	@Override public void addFirst(final T t) {
		add(0, t);
	}

	@Override public void addLast(final T t) {
		add(t);
	}

	@Override public boolean offerFirst(final T t) {
		try {

			add(0, t);
			return true;

		} catch (final IllegalStateException e) {
			return false;
		}
	}

	@Override public boolean offerLast(final T t) {
		try {

			add(t);
			return true;

		} catch (final IllegalStateException e) {
			return false;
		}
	}

	@Override public T removeFirst() {
		return remove(0);
	}

	@Override public @Nullable T pollFirst() {
		try {

			return remove(0);

		} catch (final IndexOutOfBoundsException e) {
			return null;
		}
	}

	@Override public @Nullable T pollLast() {
		try {

			return removeLast();

		} catch (final IndexOutOfBoundsException e) {
			return null;
		}
	}

	@Override public T getFirst() {
		return get(0);
	}

	@Override public @Nullable T peekFirst() {
		try {

			return get(0);

		} catch (final IndexOutOfBoundsException e) {
			return null;
		}
	}

	@Override public @Nullable T peekLast() {
		try {

			return getLast();

		} catch (final IndexOutOfBoundsException e) {
			return null;
		}
	}

	@Override public boolean removeFirstOccurrence(final Object o) {
		for (final Iterator<T> it = iterator(); it.hasNext(); ) {
			if (Objects.equals(o, it.next())) {
				it.remove();
				return true;
			}
		}

		return false;
	}

	@Override public boolean removeLastOccurrence(final Object o) {
		for (final Iterator<T> it = descendingIterator(); it.hasNext(); ) {
			if (Objects.equals(o, it.next())) {
				it.remove();
				return true;
			}
		}

		return false;
	}

	@Override public boolean offer(final T t) {
		return offerLast(t);
	}

	@Override public T remove() {
		return removeFirst();
	}

	@Override public @Nullable T poll() {
		return pollFirst();
	}

	@Override public T element() {
		return getFirst();
	}

	@Override public @Nullable T peek() {
		return peekFirst();
	}

	@Override public void push(final T t) {
		addFirst(t);
	}

	@Override public T pop() {
		return removeFirst();
	}

	class DescendingIterator implements Iterator<T> {
		private final ListIterator<T> it = listIterator(size());

		@Override
		public boolean hasNext() {
			return this.it.hasPrevious();
		}

		@Override
		@SuppressWarnings("IteratorNextCanNotThrowNoSuchElementException")
		public T next() {
			return this.it.previous();
		}

		@Override
		public void remove() {
			this.it.remove();
		}
	}

}