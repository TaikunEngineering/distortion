package engineering.taikun.distortion.structures.imp;

import engineering.taikun.distortion.Distortion;
import engineering.taikun.distortion.SerializationUtil;
import engineering.taikun.distortion.api.structures.DistortionStructObject;
import engineering.taikun.distortion.serialization.api.ByteArray;
import engineering.taikun.distortion.serialization.imp.ArrayWrapper;
import engineering.taikun.distortion.store.api.KV;
import engineering.taikun.distortion.store.imp.DebugKV;
import engineering.taikun.distortion.structures.api.DStructure;
import engineering.taikun.distortion.structures.api.DStructure.DMapStructure;
import engineering.taikun.distortion.structures.api.Struct;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.Serializable;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.*;
import java.util.stream.Collectors;

/**
 * <p>An implementation of a skiplist-map. {@link #size} requires linear time as no size counter is maintained.</p>
 *
 * <p><tt>null</tt> keys and values are allowed (though still a bad idea)</p>
 *
 * <p>All operations are approximately O(log(n))</p>
 *
 * <p>This is partially synchronized, but fully thread-safe. Iteration does not require synchronizing on the instance.
 * Reads, writes, and the conditional writes introduced with Java 8 are exclusive but multiple-step methods like
 * <tt>putAll</tt> may interleave.</p>
 *
 * <p>Node height is random with a (1/2^n) geometric distribution. Generated by an iterative 50/50 coin flip. The max
 * height of the graph can only increase by 1 at a time.</p>
 *
 * <p>Nodes are sharded such that there are log2(concurrency_level) shards for the tallest nodes. (Shorter nodes have
 * correspondingly fewer shards).</p>
 *
 * <p>Address space is from 0 to INT_MAX, allocations are performed using the key's hashcode. Collision resolution is
 * handled by linear probing with a stride determined by multiplying the hashcode with a very large prime. By doing so,
 * the stride length arbitrarily varies.</p>
 *
 * <p>Warning: this implementation does not make an exhaustive effort to fill itself to full capacity. Failure to
 * quickly find an open index will result in an exceeded capacity error. This means keys <strong>MUST</strong> have
 * non-stupid hashcode methods.</p>
 *
 * <p>IMPROVEMENT CANDIDATE: The collision resolution algorithm could be better. Deterministic probing is actually not
 * necessary as the nodes are findable through the graph versus the key's hash. The algorithm just needs to find any
 * unused index. If this sounds like something interesting to tackle, file a bug report so I can create some kind of
 * function to assess algorithm quality. In the event there's a paper I don't know about, you can simply link it in
 * the bug report.</p>
 */
@SuppressWarnings({
		"ConstantConditions", "UnnecessarilyQualifiedInnerClassAccess", "FieldAccessedSynchronizedAndUnsynchronized"
		, "LocalVariableHidesMemberVariable"
})
public class DNavigableMap<K, V, BA extends ByteArray<BA>>
		extends AbstractMap<K, V> implements DMapStructure<K, V, BA>, NavigableMap<K, V> {

	static final int HEAD = -1;
	static final int NULL = -100;

	static final ByteArray HEAD_KEY = ArrayWrapper.UTIL.new IntUnion(-1).toBA();
	static final ByteArray CONCURRENCY_KEY = ArrayWrapper.UTIL.new IntUnion(-2).toBA();
	static final ByteArray ENTROPY_KEY = ArrayWrapper.UTIL.new IntUnion(-3).toBA();
	static final ByteArray COMPARATOR_KEY = ArrayWrapper.UTIL.new IntUnion(-4).toBA();
	static final ByteArray CUSTOM_KEY = ArrayWrapper.UTIL.new IntUnion(-5).toBA();
	static final ByteArray REMOTES_KEY = ArrayWrapper.UTIL.new IntUnion(-6).toBA();

	public KV<BA> kv;
	public ByteArray key;
	public final SerializationUtil<BA> util;
	public final SerializationUtil<BA>.SerializationContext context;
	public final @Nullable Comparator<? super K> comparator;

	// lazily initialized
	// --

	private short concurrencyLevel = -1;
	byte concBits = 0;
	private int entropy = 0;

	// --

	// ignore me, I'm just here to make watch expressions work better when debugging with the *Tests
	// DNavigableMap<K, V, BA> dmap = this;

	/**
	 * Non-initializing constructor
	 */
	public DNavigableMap(
			final KV<BA> kv, final ByteArray key, final SerializationUtil<BA> util,
			final SerializationUtil<BA>.SerializationContext context
	) {
		this.kv = kv;
		this.key = key;
		this.util = util;
		this.context = context;

		final BA comparator_read = this.kv.read(COMPARATOR_KEY);

		if (comparator_read == null) {
			this.comparator = null;
		} else {
			this.comparator = (Comparator<? super K>) SerializationUtil.javaDeserialize(comparator_read);
		}
	}

	/**
	 * Initializing constructor
	 */
	public <C extends Comparator<? super K> & Serializable> DNavigableMap(
			final KV<BA> kv, final ByteArray key, final SerializationUtil<BA> util,
			final SerializationUtil<BA>.SerializationContext context, final short concurrencyLevel,
			final @Nullable C comparator
	) {
		this.kv = kv;
		this.key = key;
		this.util = util;
		this.context = context;
		this.comparator = comparator;

		this.concurrencyLevel = concurrencyLevel;
		this.concBits = (byte) Math.round(Math.log10(this.concurrencyLevel) / Math.log10(2));
		this.entropy = 0;

		this.kv.write(HEAD_KEY, util.compose(ser_intar(new int[]{ NULL }), (byte) 1));

		this.kv.write(CONCURRENCY_KEY, util.new ShortUnion(concurrencyLevel).toBA());
		this.kv.write(ENTROPY_KEY, util.new IntUnion(this.entropy).toBA());

		if (comparator != null) {
			this.kv.write(COMPARATOR_KEY, util.javaSerialize(comparator));
		}
	}

	@Override
	public synchronized KV<BA> getKV() {
		return this.kv;
	}

	@Override
	public synchronized void setKV(final KV<BA> kv) {
		this.kv = kv;
	}

	@Override
	public synchronized ByteArray getKey() {
		return this.key;
	}

	@Override
	public synchronized void setKey(final ByteArray key) {
		this.key = key;
	}

	private int allocate(final K key) {
		completeInit();
		final int hash = hash(key);

		final int index_one = hash & 0x7FFFFFFF;
		if (this.kv.read(this.util.new IntUnion(index_one).toBA()) == null) {
			return index_one;
		}

		final int stride = 1073741827 * hash;

		for (int i = 0, x = index_one + stride; i < 20; i++, x += stride) {
			if (this.kv.read(this.util.new IntUnion(x & 0x7FFFFFFF).toBA()) == null) {

				if (i + 1 > this.entropy) {
					this.entropy = i + 1;
					this.kv.write(ENTROPY_KEY, this.util.new IntUnion(this.entropy).toBA());
				}

				return i;
			}
		}

		//noinspection ConstantOnLeftSideOfComparison
		if (21 > this.entropy) {
			this.entropy = 21;
			this.kv.write(ENTROPY_KEY, this.util.new IntUnion(this.entropy).toBA());
		}

		throw new IllegalStateException("Map capacity exceeded");
	}

	private void completeInit() {
		if (this.concurrencyLevel == -1) {
			this.concurrencyLevel = this.util.new ShortUnion(this.kv.read(CONCURRENCY_KEY)).getShort();
			this.concBits =  (byte) Math.round(Math.log10(this.concurrencyLevel) / Math.log10(2));
			this.entropy = this.util.new IntUnion(this.kv.read(ENTROPY_KEY)).getInt();
		}
	}

	public synchronized short getConcurrencyLevel() {
		completeInit();
		return this.concurrencyLevel;
	}

	/**
	 * <p>Returns the highest recorded entropy value. Entropy reflects the difficulty for the allocator to find a free
	 * slot in the table. Each 1 reflects each additional read performed in order to allocate.</p>
	 *
	 * <p>As of running this method, the maximum tolerated entropy by the allocator is 20.</p>
	 *
	 * @return The worst experienced "entropy" of this map
	 */
	public synchronized float getEntropy() {
		completeInit();
		return this.entropy;
	}

	@Override
	public synchronized @Nullable String getCustomClass() {
		final BA fetch = this.kv.read(CUSTOM_KEY);

		if (fetch == null) {
			return null;
		}

		return (String) this.context.unpack(null, fetch);
	}

	@Override
	public synchronized void setCustomClass(final @NotNull String className) {
		this.kv.write(CUSTOM_KEY, this.context.serialize(className));
	}

	@Override
	public ByteArray getRemotesKey() {
		return REMOTES_KEY;
	}

	@Override
	public synchronized Comparator<? super K> comparator() {
		return this.comparator;
	}

	@Override
	public synchronized void destroy() {
		clear();
		this.kv.delete(HEAD_KEY);
		this.kv.delete(CONCURRENCY_KEY);
		this.kv.delete(ENTROPY_KEY);
		this.kv.delete(COMPARATOR_KEY);
		this.kv.delete(CUSTOM_KEY);
		final BA temp; if ((temp = this.kv.read(REMOTES_KEY)) != null) this.context.unpackAndDestroy(this.kv, temp);
		this.kv.delete(REMOTES_KEY);
	}

	class NodeCache {
		private final HashMap<Integer, PointerList> cache = new HashMap<>();

		NodeCache() {
			this.cache.put(HEAD, new Head());
		}

		PointerList getNode(final int index) {
			return this.cache.computeIfAbsent(index, Node::new);
		}
	}

	private <R> R search(
			final K key, final BiFunction<Supplier<PointerList[]>, Node, R> find, final Function<PointerList[], R> nofind
	) {
		final NodeCache cache = new NodeCache();

		PointerList active_data = cache.getNode(HEAD);
		byte layer = (byte) (active_data.getHeight() - 1);

		final PointerList[] node_history = new PointerList[layer + 1];

		node_history[layer] = active_data;

		while (true) {
			final int next_pointer = active_data.getPointer(layer);

			// compare
			// -1 a < b
			//  0 a = b
			//  1 a > b

			final int compare;
			@Nullable final PointerList next_node;
			if (next_pointer == NULL) {
				next_node = null;
				compare = -1;
			} else {
				next_node = cache.getNode(next_pointer);
				compare = compare(key, ((Node) next_node).getKey());
			}

			if (compare == 0) {
				final Node node_capture = (Node) next_node;
				final byte layer_capture = layer;

				return find.apply(() -> {

					PointerList active2 = node_history[layer_capture];
					for (byte i = (byte) (layer_capture - 1); i >= 0; i--) {
						while (true) {
							node_history[i] = active2;

							final int pointer = active2.getPointer(i);

							if (pointer == node_capture.index) {
								break;
							}

							active2 = new Node(pointer);
						}
					}

					return node_history;

				}, (Node) next_node);
			}

			if (compare < 0) { // overshoot
				if (layer == 0) {
					return nofind.apply(node_history);
				}
				active_data = node_history[layer];
				node_history[--layer] = active_data;
			} else {
				node_history[layer] = next_node;
				active_data = next_node;
			}
		}
	}

	@Override
	public synchronized boolean containsKey(final Object key) {
		return search((K) key, (a, b) -> true, a -> false);
	}

	@Override
	public synchronized @Nullable V get(final Object key) {
		return search((K) key,
				(a, node) -> (V) this.context.unpack(
						this.kv, this.kv.read(this.util.compose((byte) 0x00, this.util.new IntUnion(node.index).getBytes()))
				), a -> null
		);
	}

	private class PutResult extends PutReflection {
		final @Nullable V v_result;

		PutResult(final DStructure key_reflection, final DStructure value_reflection, final @Nullable V v_result) {
			super(key_reflection, value_reflection);
			this.v_result = v_result;
		}
	}

	private PutResult internalPut(final K key, final V value) {
		return search(key, (a, node) -> {
			final BA value_key = this.util.compose((byte) 0x00, this.util.new IntUnion(node.index).getBytes());
			final V toreturn = (V) this.context.unpackAndDestroy(this.kv, this.kv.read(value_key));
			final DStructure value_reflection = this.context.store(this.kv, value_key, value);
			return new PutResult(null, value_reflection, toreturn);
		}, history -> {
			final int head_height = history[history.length - 1].getHeight();

			final int index = allocate(key);
			final int height = getLevel(head_height + 1);

			final int[] node_pointers = new int[height];

			if (height > head_height) {
				node_pointers[head_height] = NULL;

				if (history[history.length - 1] instanceof DNavigableMap.Head) {
					((Head) history[history.length - 1]).addTop(index);
				} else {
					new Head().addTop(index);
				}
			}

			for (byte i = 0; i < Math.min(height, head_height); i++) {
				node_pointers[i] = history[i].getPointer(i);
				history[i].modifyPointer(i, index);
			}

			final DStructure key_reflection = new Node(index, node_pointers, key, head_height).reflection;

			final DStructure value_reflection
					= this.context.store(this.kv, this.util.compose((byte) 0x00, this.util.new IntUnion(index).getBytes()), value);

			return new PutResult(key_reflection, value_reflection, null);
		});
	}

	@Override
	public synchronized @Nullable V put(final K key, final V value) {
		return internalPut(key, value).v_result;
	}

	@Override
	public synchronized PutReflection reflectingPut(final K key, final V value) {
		return internalPut(key, value);
	}

	@Override
	public synchronized @Nullable V remove(final Object key) {
		return search((K) key, (history_sup, node) -> removeHelper(history_sup.get(), node), a -> null);
	}

	private V removeHelper(final PointerList[] history, final Node node) {
		for (byte i = 0; i < node.getHeight(); i++) {
			history[i].modifyPointer(i, node.getPointer(i));
		}

		final BA index_bytes = this.util.new IntUnion(node.index).toBA();
		final BA index_read = this.kv.read(index_bytes);

		if (node.split_height == 0) {
			this.context.unpackAndDestroy(this.kv, index_read.slice(2 + 4 * node.pointers.length, index_read.length()));
		} else {
			this.context.unpackAndDestroy(this.kv, index_read.slice(2 + 4, index_read.length()));
		}

		this.kv.delete(index_bytes);

		for (byte i = 1; i <= node.split_height; i++) {
			this.kv.delete(this.util.compose(index_bytes, i));
		}

		final BA value_index = this.util.compose((byte) 0x00, this.util.new IntUnion(node.index).getBytes());
		final V toreturn = (V) this.context.unpackAndDestroy(this.kv, this.kv.read(value_index));
		this.kv.delete(value_index);

		// head trimming

		byte trim_amount = 0;
		final Head head;
		if (history[history.length - 1] instanceof DNavigableMap.Head) {
			head = (Head) history[history.length - 1];
		} else {
			head = new Head();
		}
		for (byte i = (byte) (head.getHeight() - 1); i > 0; i--) {

			if (head.getPointer(i) == NULL) {
				trim_amount++;
			} else {
				break;
			}
		}

		if (trim_amount > 0) {
			head.trim(trim_amount);
		}

		return toreturn;
	}

	// navigable support

	@Nullable Node nullableLookup(final int index) {
		if (index == NULL) {
			return null;
		} else {
			return new Node(index);
		}
	}

	Entry<K, V> nodeToEntry(final @Nullable Node node) {
		if (node == null) {
			return null;
		}

		final BA index = this.util.compose((byte) 0x00, this.util.new IntUnion(node.index).getBytes());
		return new DEntry(node::getKey, () -> (V) this.context.unpack(this.kv, this.kv.read(index)), index);
	}

	K nodeToKey(final @Nullable Node node) {
		if (node == null) {
			return null;
		}

		return node.getKey();
	}

	/**
	 * greatest key strictly less than the given key
	 */
	@Nullable Node lowerNode(final K key) {
		return search(key, (history_sup, a) -> lnHelper(history_sup.get()), this::lnHelper);
	}

	@Nullable Node lnHelper(final PointerList[] history) {
		if (history[0] instanceof DNavigableMap.Head) {
			return null;
		} else {
			return (Node) history[0];
		}
	}

	@Override public synchronized Entry<K, V> lowerEntry(final K key) {
		return nodeToEntry(lowerNode(key));
	}

	@Override public synchronized K lowerKey(final K key) {
		return nodeToKey(lowerNode(key));
	}

	/**
	 * greatest key less than or equal than the given key
	 */
	@Nullable Node floorNode(final K key) {
		return search(key, (a, node) -> node, history -> {
			if (history[0] instanceof DNavigableMap.Head) {
				return null;
			} else {
				return (Node) history[0];
			}
		});
	}

	@Override public synchronized Entry<K, V> floorEntry(final K key) {
		return nodeToEntry(floorNode(key));
	}

	@Override public synchronized K floorKey(final K key) {
		return nodeToKey(floorNode(key));
	}


	/**
	 * least key greater than or equal than the given key
	 */
	@Nullable Node ceilingNode(final K key) {
		return search(key, (a, node) -> node, history -> nullableLookup(history[0].getPointer((byte) 0)));
	}

	@Override public synchronized Entry<K, V> ceilingEntry(final K key) {
		return nodeToEntry(ceilingNode(key));
	}

	@Override public synchronized K ceilingKey(final K key) {
		return nodeToKey(ceilingNode(key));
	}


	/**
	 * least key strictly greater than the given key
	 */
	@Nullable Node higherNode(final K key) {
		return search(key,
				(a, node) -> nullableLookup(node.getPointer((byte) 0)),
				history -> nullableLookup(history[0].getPointer((byte) 0))
		);
	}

	@Override public synchronized Entry<K, V> higherEntry(final K key) {
		return nodeToEntry(higherNode(key));
	}

	@Override public synchronized K higherKey(final K key) {
		return nodeToKey(higherNode(key));
	}

	/**
	 * first key
	 */
	@Nullable Node firstNode() {
		return nullableLookup(new Head().getPointer((byte) 0));
	}

	@Override public synchronized Entry<K, V> firstEntry() {
		return nodeToEntry(firstNode());
	}

	@Override public synchronized K firstKey() {
		return nodeToKey(firstNode());
	}

	// single scan optimized
	@Override public synchronized @Nullable Entry<K, V> pollFirstEntry() {
		final Head head = new Head();
		final int node_index = head.getPointer((byte) 0);

		if (node_index == NULL) {
			return null;
		}

		final Node node = new Node(node_index);
		final PointerList[] pointers = new PointerList[head.getHeight()];
		Arrays.fill(pointers, head);

		return new DEntry(node::getKey, () -> removeHelper(pointers, node), null);
	}

	/**
	 * last key
	 */
	@Nullable Node lastNode() {
		final Head head = new Head();

		PointerList active_node = head;
		for (byte level = (byte) (head.getHeight() - 1); level >= 0; level--) {
			while (true) {
				final int pointer = active_node.getPointer(level);

				if (pointer == NULL) {
					break;
				}

				active_node = new Node(pointer);
			}
		}

		if (active_node == head) {
			return null;
		}
		return (Node) active_node;
	}

	@Override public synchronized Entry<K, V> lastEntry() {
		return nodeToEntry(lastNode());
	}

	@Override public synchronized K lastKey() {
		return nodeToKey(lastNode());
	}

	// single scan optimized
	@Override public synchronized @Nullable Entry<K, V> pollLastEntry() {
		final Head head = new Head();

		final PointerList[] history = new PointerList[head.getHeight()];
		Node toremove = null;
		for (byte level = (byte) (head.getHeight() - 1); level >= 0; level--) {
			PointerList prev_active_node = null;
			PointerList active_node = head;

			while (true) {
				history[level] = prev_active_node;

				final int pointer = active_node.getPointer(level);

				if (pointer == NULL) {
					break;
				}

				prev_active_node = active_node;
				active_node = toremove = new Node(pointer);
			}
		}

		if (history[0] == null) {
			return null;
		}

		final Node node_capture = toremove;
		return new DEntry(toremove::getKey, () -> removeHelper(history, node_capture), null);
	}

	int[] deser_intar(final ByteArray array) {
		final int[] toreturn = new int[array.length() / 4];

		for (int i = 0; i < toreturn.length; i++) {
			toreturn[i] = this.util.new IntUnion(
					array.read(4 * i), array.read(1 + 4 * i), array.read(2 + 4 * i), array.read(3 + 4 * i)
			).getInt();
		}

		return toreturn;
	}

	BA ser_intar(final int[] array) {
		return ser_intar(array, 0);
	}

	/**
	 * @param offset into the int array arg
	 */
	BA ser_intar(final int[] array, final int offset) {
		final BA toreturn = this.util.allocate((array.length - offset) * 4);

		for (int i = offset; i < array.length; i++) {
			final byte[] intar = this.util.new IntUnion(array[i]).getBytes();

			toreturn.write((i - offset) * 4, intar[0]);
			toreturn.write((i - offset) * 4 + 1, intar[1]);
			toreturn.write((i - offset) * 4 + 2, intar[2]);
			toreturn.write((i - offset) * 4 + 3, intar[3]);
		}

		return toreturn;
	}

	interface PointerList {
		byte getHeight();

		int getPointer(byte level);

		void modifyPointer(byte level, int value);
	}

	class Head implements PointerList {
		private int[] pointers;

		Head() {
			final BA head_read = DNavigableMap.this.kv.read(HEAD_KEY);
			this.pointers = new int[head_read.read(4)];
			this.pointers[this.pointers.length - 1] = DNavigableMap.this.util.new IntUnion(head_read.slice(0, 4)).getInt();
			Arrays.fill(this.pointers, 0, this.pointers.length - 1, -1);
		}

		@Override
		public byte getHeight() {
			return (byte) this.pointers.length;
		}

		@Override
		public int getPointer(final byte level) {
			if (this.pointers[level] == -1) {

				this.pointers[level] = DNavigableMap.this.util.new IntUnion(
						DNavigableMap.this.kv.read(DNavigableMap.this.util.compose(HEAD_KEY, level))
				).getInt();
			}

			return this.pointers[level];
		}

		@Override
		public void modifyPointer(final byte level, final int value) {
			this.pointers[level] = value;

			if (level == this.pointers.length - 1) {

				DNavigableMap.this.kv.write(
						HEAD_KEY,
						DNavigableMap.this.util.compose(DNavigableMap.this.util.new IntUnion(value).toBA(), (byte) this.pointers.length)
				);

			} else {

				DNavigableMap.this.kv.write(
						DNavigableMap.this.util.compose(HEAD_KEY, level),
						DNavigableMap.this.util.new IntUnion(value).toBA()
				);
			}
		}

		void addTop(final int value) {
			this.pointers = Arrays.copyOf(this.pointers, this.pointers.length + 1);
			this.pointers[this.pointers.length - 1] = value;

			DNavigableMap.this.kv.write(
					HEAD_KEY,
					DNavigableMap.this.util.compose(DNavigableMap.this.util.new IntUnion(value).toBA(), (byte) this.pointers.length)
			);

			DNavigableMap.this.kv.write(
					DNavigableMap.this.util.compose(HEAD_KEY, (byte) (this.pointers.length - 2)),
					DNavigableMap.this.util.new IntUnion(this.pointers[this.pointers.length - 2]).toBA()
			);
		}

		void trim(final byte amount) {
			final int height = this.pointers.length;

			DNavigableMap.this.kv.write(
					HEAD_KEY,
					DNavigableMap.this.util.compose(
							DNavigableMap.this.util.new IntUnion(getPointer((byte) (height - amount - 1))).toBA(),
							(byte) (this.pointers.length - amount)
					)
			);

			for (int i = 0; i < amount; i++) {
				DNavigableMap.this.kv.delete(DNavigableMap.this.util.compose(HEAD_KEY, (byte) (height - i - 2)));
			}
		}

		@Override public String toString() {
			return "Head{" +
					"pointers=" + Arrays.toString(this.pointers) +
					'}';
		}
	}

	@SuppressWarnings("InnerClassFieldHidesOuterClassField")
	class Node implements PointerList {
		final int index;
		private K key = (K) DMap.UNINIT;

		final byte split_height;
		final int[] pointers;

		DStructure reflection = null;

		Node(final int index) {
			final BA header = DNavigableMap.this.kv.read(DNavigableMap.this.util.new IntUnion(index).toBA());

			this.index = index;
			this.split_height = header.read(0);

			if (this.split_height == 0) {

				this.pointers = deser_intar(header.slice(2, 2 + 4 * header.read(1)));

			}	else {

				this.pointers = new int[header.read(1)];

				this.pointers[0] = DNavigableMap.this.util.new IntUnion(
						header.read(2), header.read(3), header.read(4), header.read(5)
				).getInt();

				Arrays.fill(this.pointers, 1, this.pointers.length, -1);

			}
		}

		Node(final int index, final int[] pointers, final K key, final int head_height) {
			this.index = index;
			this.key = key;
			this.split_height
					= (byte) Math.min(Math.max(0, pointers.length - head_height + DNavigableMap.this.concBits), pointers.length);

			this.pointers = pointers;

			if (this.split_height == 0) {

				this.reflection = DNavigableMap.this.context.store(
						DNavigableMap.this.kv, DNavigableMap.this.util.new IntUnion(index).toBA(),
						DNavigableMap.this.util.compose(this.split_height, (byte) pointers.length, ser_intar(pointers)),
						key
				);

			} else {

				this.reflection = DNavigableMap.this.context.store(
						DNavigableMap.this.kv, DNavigableMap.this.util.new IntUnion(index).toBA(), DNavigableMap.this.util.compose(
								this.split_height, (byte) pointers.length, DNavigableMap.this.util.new IntUnion(pointers[0]).toBA()
						), key
				);

				for (int i = 1; i < this.split_height; i++) {
					DNavigableMap.this.kv.write(
							DNavigableMap.this.util.compose(DNavigableMap.this.util.new IntUnion(index).toBA(), (byte) i),
							DNavigableMap.this.util.new IntUnion(pointers[i]).toBA()
					);
				}

				if (this.split_height != pointers.length) {
					DNavigableMap.this.kv.write(
							DNavigableMap.this.util.compose(DNavigableMap.this.util.new IntUnion(index).toBA(), this.split_height),
							ser_intar(pointers, this.split_height)
					);
				}
			}
		}

		public K getKey() {
			if (this.key == DMap.UNINIT) {
				final BA header = DNavigableMap.this.kv.read(DNavigableMap.this.util.new IntUnion(this.index).toBA());

				if (this.split_height == 0) {

					this.key = (K) DNavigableMap.this.context.unpack(
							DNavigableMap.this.kv, header.slice(2 + 4 * this.pointers.length, header.length())
					);

				} else {

					this.key = (K) DNavigableMap.this.context.unpack(
							DNavigableMap.this.kv, header.slice(2 + 4, header.length())
					);

				}
			}

			return this.key;
		}

		@Override
		public byte getHeight() {
			return (byte) this.pointers.length;
		}

		@Override
		public int getPointer(final byte level) {
			if (this.pointers[level] == -1) {
				if (level < this.split_height) {

					this.pointers[level] = DNavigableMap.this.util.new IntUnion(
							DNavigableMap.this.kv.read(DNavigableMap.this.util.compose(
									DNavigableMap.this.util.new IntUnion(this.index).toBA(), level
							))
					).getInt();

				} else {

					final int[] dump = deser_intar(DNavigableMap.this.kv.read(DNavigableMap.this.util.compose(
							DNavigableMap.this.util.new IntUnion(this.index).toBA(), this.split_height
					)));

					System.arraycopy(dump, 0, this.pointers, this.split_height, dump.length);

				}
			}

			return this.pointers[level];
		}

		@Override
		public void modifyPointer(final byte level, final int value) {
			this.pointers[level] = value;
			final BA value_bytes = DNavigableMap.this.util.new IntUnion(value).toBA();

			if (level == 0 || this.split_height == 0) {

				final BA index_bytes = DNavigableMap.this.util.new IntUnion(this.index).toBA();
				final BA read_bytes = DNavigableMap.this.kv.read(index_bytes);

				final int offset = level * 4 + 2;

				read_bytes.write(offset, value_bytes.read(0));
				read_bytes.write(offset + 1, value_bytes.read(1));
				read_bytes.write(offset + 2, value_bytes.read(2));
				read_bytes.write(offset + 3, value_bytes.read(3));

				DNavigableMap.this.kv.write(index_bytes, read_bytes);

			} else if (level < this.split_height) {

				DNavigableMap.this.kv.write(
						DNavigableMap.this.util.compose(DNavigableMap.this.util.new IntUnion(this.index).toBA(), level),
						value_bytes
				);

			} else {

				final BA index_bytes
						= DNavigableMap.this.util.compose(DNavigableMap.this.util.new IntUnion(this.index).toBA(), this.split_height);
				final BA read_bytes = DNavigableMap.this.kv.read(index_bytes);

				final int offset = (level - this.split_height) * 4;

				read_bytes.write(offset, value_bytes.read(0));
				read_bytes.write(offset + 1, value_bytes.read(1));
				read_bytes.write(offset + 2, value_bytes.read(2));
				read_bytes.write(offset + 3, value_bytes.read(3));

				DNavigableMap.this.kv.write(index_bytes, read_bytes);
			}
		}

		@Override public String toString() {
			return "Node{" +
					"index=" + this.index +
					", key=" + this.getKey() +
					", split_height=" + this.split_height +
					", pointers=" + Arrays.toString(this.pointers) +
					'}';
		}
	}

	@SuppressWarnings("InnerClassFieldHidesOuterClassField")
	class DEntry implements Entry<K, V> {

		final Supplier<K> key;
		final Supplier<V> value;
		V cached_value = (V) DMap.UNINIT;
		final @Nullable BA index;

		DEntry(final Supplier<K> key, final Supplier<V> value, final @Nullable BA index) {
			this.key = key;
			this.value = value;
			this.index = index;
		}

		@Override public K getKey() {
			return this.key.get();
		}

		@Override public V getValue() {
			synchronized (DNavigableMap.this) {
				if (this.cached_value == DMap.UNINIT) {
					this.cached_value = this.value.get();
				}
				return this.cached_value;
			}
		}

		@Override public V setValue(final V newValue) {
			synchronized (DNavigableMap.this) {
				if (this.index == null) {
					throw new IllegalStateException("Removed entries cannot have value reassigned");
				}

				final V oldValue = (V) DNavigableMap.this.context.unpackAndDestroy(
						DNavigableMap.this.kv, DNavigableMap.this.kv.read(this.index)
				);

//				if (Distortion.DEBUG) {
//					final V oldValue = this.value.get();
//
//					if (!unpack_value.equals(oldValue)) {
//						throw new RuntimeException();
//					}
//				}

				this.cached_value = newValue;
				DNavigableMap.this.context.store(DNavigableMap.this.kv, this.index, newValue);
				return oldValue;
			}
		}

		@Override public String toString() {
			return getKey() + "=" + getValue();
		}

		@Override public int hashCode() {
			return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
		}

		@Override public boolean equals(final Object o) {
			if (o == this)
				return true;
			if (o instanceof Entry) {
				final Entry<?,?> e = (Entry<?,?>) o;
				if (Objects.equals(getKey(), e.getKey()) &&
						Objects.equals(getValue(), e.getValue()))
					return true;
			}
			return false;
		}
	}

	private @Nullable ToIntFunction hash_cache = null;

	@SuppressWarnings("IfStatementWithIdenticalBranches")
	private int hash(final K key) {
		if (this.hash_cache != null) {
			return this.hash_cache.applyAsInt(key);
		} else {
			if (key instanceof boolean[]) {
				this.hash_cache = (ToIntFunction<boolean[]>) Arrays::hashCode;
			} else if (key instanceof byte[]) {
				this.hash_cache = (ToIntFunction<byte[]>) Arrays::hashCode;
			} else if (key instanceof char[]) {
				this.hash_cache = (ToIntFunction<char[]>) Arrays::hashCode;
			} else if (key instanceof short[]) {
				this.hash_cache = (ToIntFunction<short[]>) Arrays::hashCode;
			} else if (key instanceof int[]) {
				this.hash_cache = (ToIntFunction<int[]>) Arrays::hashCode;
			} else if (key instanceof long[]) {
				this.hash_cache = (ToIntFunction<long[]>) Arrays::hashCode;
			} else if (key instanceof float[]) {
				this.hash_cache = (ToIntFunction<float[]>) Arrays::hashCode;
			} else if (key instanceof double[]) {
				this.hash_cache = (ToIntFunction<double[]>) Arrays::hashCode;
			} else {
				this.hash_cache = Object::hashCode;
			}
			return this.hash_cache.applyAsInt(key);
		}
	}

	// compare
	// -1 a < b
	//  0 a = b
	//  1 a > b

	private @Nullable Comparator comp_cache = null;

	int compare(final K left, final K right) {
		if (this.comp_cache != null) {
			return this.comp_cache.compare(left, right);
		} else {
			if (this.comparator != null) {
				this.comp_cache = this.comparator;
			} else if (left instanceof boolean[]) {
				this.comp_cache = SerializationUtil.boolar_comp;
			} else if (left instanceof byte[]) {
				this.comp_cache = SerializationUtil.bytear_comp;
			} else if (left instanceof char[]) {
				this.comp_cache = SerializationUtil.charar_comp;
			} else if (left instanceof short[]) {
				this.comp_cache = SerializationUtil.shortar_comp;
			} else if (left instanceof int[]) {
				this.comp_cache = SerializationUtil.intar_comp;
			} else if (left instanceof long[]) {
				this.comp_cache = SerializationUtil.longar_comp;
			} else if (left instanceof float[]) {
				this.comp_cache = SerializationUtil.floatar_comp;
			} else if (left instanceof double[]) {
				this.comp_cache = SerializationUtil.doublear_comp;
			} else {
				this.comp_cache = (l, r) -> ((Comparable) l).compareTo(r);
			}
			return this.comp_cache.compare(left, right);
		}
	}

//	public static int[] levels = {1, 2, 2, 1, 2, 1};
//	public static int lindex = 0;
//
//	public static int getLevel_(final int max) {
//		return levels[lindex++];
//	}
//
//	public static ArrayList<Integer> level_history = new ArrayList<>();
//
//	public static int getLevel(final int max) {
//		final int capture = getLevel__(max);
//		level_history.add(capture);
//		return capture;
//	}

	public static final double level_1 = 0.5;
	public static final double level_2 = 0.75;
	public static final double level_3 = 0.875;
	public static final double level_4 = 0.9375;
	public static final double level_5 = 0.96875;
	public static final double level_6 = 0.984375;

	public static int getLevel(final int max) {

		int sum = 0;

		while (true) {

			final double rand = ThreadLocalRandom.current().nextDouble();

			if (rand < level_1) {

				return Math.min(sum + 1, max);

			} else if (rand < level_2) {

				return Math.min(sum + 2, max);

			} else if (rand < level_3) {

				return Math.min(sum + 3, max);

			} else if (rand < level_4) {

				return Math.min(sum + 4, max);

			} else if (rand < level_5) {

				return Math.min(sum + 5, max);

			} else if (rand < level_6) {

				return Math.min(sum + 6, max);

			} else if (sum + 6 >= max) {

				return max;

			} else {
				sum += 6;
			}
		}
	}

	static class SubMapContainer<K, V, BA extends ByteArray<BA>>
			extends DistortionStructObject implements NavigableMap<K, V> {

		transient NavigableMap<K, V> embed;

		SubMapContainer(
				final DNavigableMap<K, V, BA> root,
				final boolean headmap, final @Nullable K min, final boolean min_inclusive,
				final boolean tailmap, final @Nullable K max, final boolean max_inclusive,
				final boolean backwards
		) {
			super(new SimpleStruct(8));

			final Struct struct = struct();

			struct.set(0, root);

			struct.set(1, min);
			struct.set(2, headmap);
			struct.set(3, min_inclusive);

			struct.set(4, max);
			struct.set(5, tailmap);
			struct.set(6, max_inclusive);

			struct.set(7, backwards);

			this.embed = root.new SubMap(
					headmap, min, min_inclusive,
					tailmap, max, max_inclusive,
					backwards
			);
		}

		@Override
		public void distortionInit() {

			final Struct struct = struct();

			final DNavigableMap<K, V, BA> root = (DNavigableMap<K, V, BA>) struct.get(0);

			final boolean headmap = (boolean) struct.get(1);
			final @Nullable K min = (K) struct.get(2);
			final boolean min_inclusive = (boolean) struct.get(3);

			final boolean tailmap = (boolean) struct.get(4);
			final @Nullable K max = (K) struct.get(5);
			final boolean max_inclusive = (boolean) struct.get(6);

			final boolean backwards = (boolean) struct.get(7);

			this.embed = root.new SubMap(
					headmap, min, min_inclusive,
					tailmap, max, max_inclusive,
					backwards
			);
		}

		@Override public Entry<K, V> lowerEntry(final K key) { return this.embed.lowerEntry(key); }
		@Override public K lowerKey(final K key) { return this.embed.lowerKey(key); }
		@Override public Entry<K, V> floorEntry(final K key) { return this.embed.floorEntry(key); }
		@Override public K floorKey(final K key) { return this.embed.floorKey(key); }
		@Override public Entry<K, V> ceilingEntry(final K key) { return this.embed.ceilingEntry(key); }
		@Override public K ceilingKey(final K key) { return this.embed.ceilingKey(key); }
		@Override public Entry<K, V> higherEntry(final K key) { return this.embed.higherEntry(key); }
		@Override public K higherKey(final K key) { return this.embed.higherKey(key); }
		@Override public Entry<K, V> firstEntry() { return this.embed.firstEntry(); }
		@Override public Entry<K, V> lastEntry() { return this.embed.lastEntry(); }
		@Override public Entry<K, V> pollFirstEntry() { return this.embed.pollFirstEntry(); }
		@Override public Entry<K, V> pollLastEntry() { return this.embed.pollLastEntry(); }
		@Override public NavigableMap<K, V> descendingMap() { return this.embed.descendingMap(); }
		@Override public NavigableSet<K> navigableKeySet() { return this.embed.navigableKeySet(); }
		@Override public NavigableSet<K> descendingKeySet() { return this.embed.descendingKeySet(); }
		@Override public NavigableMap<K, V> subMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) { return this.embed.subMap(fromKey, fromInclusive, toKey, toInclusive); }
		@Override public NavigableMap<K, V> headMap(final K toKey, final boolean inclusive) { return this.embed.headMap(toKey, inclusive); }
		@Override public NavigableMap<K, V> tailMap(final K fromKey, final boolean inclusive) { return this.embed.tailMap(fromKey, inclusive); }
		@Override public Comparator<? super K> comparator() { return this.embed.comparator(); }
		@Override public @NotNull SortedMap<K, V> subMap(final K fromKey, final K toKey) { return this.embed.subMap(fromKey, toKey); }
		@Override public @NotNull SortedMap<K, V> headMap(final K toKey) { return this.embed.headMap(toKey); }
		@Override public @NotNull SortedMap<K, V> tailMap(final K fromKey) { return this.embed.tailMap(fromKey); }
		@Override public K firstKey() { return this.embed.firstKey(); }
		@Override public K lastKey() { return this.embed.lastKey(); }
		@Override public int size() { return this.embed.size(); }
		@Override public boolean isEmpty() { return this.embed.isEmpty(); }
		@Override public boolean containsKey(final Object key) { return this.embed.containsKey(key); }
		@Override public boolean containsValue(final Object value) { return this.embed.containsValue(value); }
		@Override public V get(final Object key) { return this.embed.get(key); }
		@Override public V put(final K key, final V value) { return this.embed.put(key, value); }
		@Override public V remove(final Object key) { return this.embed.remove(key); }
		@Override public void putAll(@NotNull final Map<? extends K, ? extends V> m) { this.embed.putAll(m); }
		@Override public void clear() { this.embed.clear(); }
		@Override public @NotNull Set<K> keySet() { return this.embed.keySet(); }
		@Override public @NotNull Collection<V> values() { return this.embed.values(); }
		@Override public @NotNull Set<Entry<K, V>> entrySet() { return this.embed.entrySet(); }
		@Override public V getOrDefault(final Object key, final V defaultValue) { return this.embed.getOrDefault(key, defaultValue); }
		@Override public void forEach(final BiConsumer<? super K, ? super V> action) { this.embed.forEach(action); }
		@Override public void replaceAll(final BiFunction<? super K, ? super V, ? extends V> function) { this.embed.replaceAll(function); }
		@Override public V putIfAbsent(final K key, final V value) { return this.embed.putIfAbsent(key, value); }
		@Override public boolean remove(final Object key, final Object value) { return this.embed.remove(key, value); }
		@Override public boolean replace(final K key, final V oldValue, final V newValue) { return this.embed.replace(key, oldValue, newValue); }
		@Override public V computeIfPresent(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) { return this.embed.computeIfPresent(key, remappingFunction); }
		@Override public V compute(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) { return this.embed.compute(key, remappingFunction); }
		@Override public V merge(final K key, final V value, final BiFunction<? super V, ? super V, ? extends V> remappingFunction) { return this.embed.merge(key, value, remappingFunction); }
	}

	@SuppressWarnings("LocalVariableHidesMemberVariable")
	private class SubMap extends AbstractMap<K, V> implements NavigableMap<K, V> {

		final boolean headmap;
		final K min;
		final boolean min_inclusive;

		final boolean tailmap;
		final K max;
		final boolean max_inclusive;

		final boolean backwards;

		SubMap(
				final boolean headmap, final @Nullable K min, final boolean min_inclusive,
				final boolean tailmap, final @Nullable K max, final boolean max_inclusive,
				final boolean backwards
		) {
			this.min = min;
			this.headmap = headmap;
			this.min_inclusive = min_inclusive;

			this.max = max;
			this.tailmap = tailmap;
			this.max_inclusive = max_inclusive;

			this.backwards = backwards;
		}

		@Override public Comparator<? super K> comparator() {
			return this.backwards ? Collections.reverseOrder(DNavigableMap.this.comparator) : DNavigableMap.this.comparator;
		}

		@Override public boolean containsKey(final Object key) {
			if (keyNotInRange((K) key)) {
				return false;
			} else {
				return DNavigableMap.this.containsKey(key);
			}
		}

		@Override public @Nullable V get(final Object key) {
			if (keyNotInRange((K) key)) {
				return null;
			} else {
				return DNavigableMap.this.get(key);
			}
		}

		@Override public @Nullable V put(final K key, final V value) {
			if (keyNotInRange(key)) {
				throw new IllegalArgumentException("Key out of range in submap");
			} else {
				return DNavigableMap.this.put(key, value);
			}
		}

		@Override public @Nullable V remove(final Object key) {
			if (keyNotInRange((K) key)) {
				return null;
			} else {
				return DNavigableMap.this.remove(key);
			}
		}

		@Override
		public @NotNull Set<Entry<K, V>> entrySet() {
			return new AbstractSet<Entry<K, V>>() {
				@Override
				public @NotNull Iterator<Entry<K, V>> iterator() {
					return new Iterator<Entry<K, V>>() {

						Node cursor = null;
						@Nullable Node next = firstNode();
						@Nullable Node deletenode = null;

						@Override
						public boolean hasNext() {
							return this.next != null;
						}

						@Override public Entry<K, V> next() {
							if (!hasNext())
								throw new NoSuchElementException();

							this.cursor = this.next;
							this.deletenode = this.cursor;

							this.next = higherNode(this.cursor.getKey());

							final BA index = DNavigableMap.this.util.compose(
									(byte) 0x00, DNavigableMap.this.util.new IntUnion(this.cursor.index).getBytes()
							);
							return new DEntry(
									((Node) this.cursor)::getKey,
									() -> (V) DNavigableMap.this.context.unpack(DNavigableMap.this.kv, DNavigableMap.this.kv.read(index)),
									index
							) {
								@Override
								public V setValue(final V newValue) {
									if (deletenode == null)
										throw new IllegalStateException();

									return super.setValue(newValue);
								}
							};
						}

						@Override
						public void remove() {
							if (this.deletenode == null)
								throw new IllegalStateException();

							DNavigableMap.this.remove(this.deletenode.getKey());

							this.deletenode = null;
						}
					};
				}

				@Override public int size() {
					synchronized (DNavigableMap.this) {
						int count = 0;
						for (final Entry<K, V> ignored : this) {
							count++;
						}
						return count;
					}
				}
			};
		}

		private boolean keyNotInRange(final K key) {
			if (!this.headmap) {
				final int compare = compare(key, this.min);
				if (this.min_inclusive ? compare == -1 : compare <= 0) {
					return true;
				}
			}

			if (!this.tailmap) {
				final int compare = compare(key, this.max);
				if (this.max_inclusive ? compare == 1 : compare >= 0) {
					return true;
				}
			}
			return false;
		}

		@Nullable Node nodeOrNull(final @Nullable Node node) {
			if (node == null || keyNotInRange(node.getKey())) {
				return null;
			} else {
				return node;
			}
		}

		/**
		 * greatest key strictly less than the given key
		 */
		@Nullable Node lowerNode(final K key) {
			if (this.backwards) {
				if (!this.headmap && compare(this.min, key) > 0) {
					if (this.min_inclusive) {
						return nodeOrNull(DNavigableMap.this.ceilingNode(this.min));
					} else {
						return nodeOrNull(DNavigableMap.this.higherNode(this.min));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.higherNode(key));
				}
			} else {
				if (!this.tailmap && compare(this.max, key) < 0) {
					if (this.max_inclusive) {
						return nodeOrNull(DNavigableMap.this.floorNode(this.max));
					} else {
						return nodeOrNull(DNavigableMap.this.lowerNode(this.max));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.lowerNode(key));
				}
			}
		}


		@Override public Entry<K, V> lowerEntry(final K key) {
			return nodeToEntry(lowerNode(key));
		}

		@Override public K lowerKey(final K key) {
			return nodeToKey(lowerNode(key));
		}

		/**
		 * greatest key less than or equal than the given key
		 */
		@Nullable Node floorNode(final K key) {
			if (this.backwards) {
				if (!this.headmap && compare(this.min, key) >= 0) {
					if (this.min_inclusive) {
						return nodeOrNull(DNavigableMap.this.ceilingNode(this.min));
					} else {
						return nodeOrNull(DNavigableMap.this.higherNode(this.min));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.ceilingNode(key));
				}
			} else {
				if (!this.tailmap && compare(this.max, key) <= 0) {
					if (this.max_inclusive) {
						return nodeOrNull(DNavigableMap.this.floorNode(this.max));
					} else {
						return nodeOrNull(DNavigableMap.this.lowerNode(this.max));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.floorNode(key));
				}
			}
		}

		@Override public Entry<K, V> floorEntry(final K key) {
			return nodeToEntry(floorNode(key));
		}

		@Override public K floorKey(final K key) {
			return nodeToKey(floorNode(key));
		}

		/**
		 * least key greater than or equal than the given key
		 */
		@Nullable Node ceilingNode(final K key) {
			if (this.backwards) {
				if (!this.tailmap && compare(this.max, key) <= 0) {
					if (this.max_inclusive) {
						return nodeOrNull(DNavigableMap.this.floorNode(this.max));
					} else {
						return nodeOrNull(DNavigableMap.this.lowerNode(this.max));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.floorNode(key));
				}
			} else {
				if (!this.headmap && compare(this.min, key) >= 0) {
					if (this.min_inclusive) {
						return nodeOrNull(DNavigableMap.this.ceilingNode(this.min));
					} else {
						return nodeOrNull(DNavigableMap.this.higherNode(this.min));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.ceilingNode(key));
				}
			}
		}

		@Override public Entry<K, V> ceilingEntry(final K key) {
			return nodeToEntry(ceilingNode(key));
		}

		@Override public K ceilingKey(final K key) {
			return nodeToKey(ceilingNode(key));
		}

		/**
		 * least key strictly greater than the given key
		 */
		@Nullable Node higherNode(final K key) {
			if (this.backwards) {
				if (!this.tailmap && compare(this.max, key) < 0) {
					if (this.max_inclusive) {
						return nodeOrNull(DNavigableMap.this.floorNode(this.max));
					} else {
						return nodeOrNull(DNavigableMap.this.lowerNode(this.max));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.lowerNode(key));
				}
			} else {
				if (!this.headmap && compare(this.min, key) > 0) {
					if (this.min_inclusive) {
						return nodeOrNull(DNavigableMap.this.ceilingNode(this.min));
					} else {
						return nodeOrNull(DNavigableMap.this.higherNode(this.min));
					}
				} else {
					return nodeOrNull(DNavigableMap.this.higherNode(key));
				}
			}
		}

		@Override public Entry<K, V> higherEntry(final K key) {
			return nodeToEntry(higherNode(key));
		}

		@Override public K higherKey(final K key) {
			return nodeToKey(higherNode(key));
		}

		/**
		 * first key
		 */
		@Nullable Node firstNode() {
			if (this.backwards) {
				if (this.tailmap) {
					return DNavigableMap.this.lastNode();
				} else if (this.max_inclusive) {
					return ceilingNode(this.max);
				} else {
					return higherNode(this.max);
				}
			} else {
				if (this.headmap) {
					return DNavigableMap.this.firstNode();
				} else if (this.min_inclusive) {
					return ceilingNode(this.min);
				} else {
					return higherNode(this.min);
				}
			}
		}

		@Override public Entry<K, V> firstEntry() {
			return nodeToEntry(firstNode());
		}

		@Override public K firstKey() {
			return nodeToKey(firstNode());
		}

		@Override public Entry<K, V> pollFirstEntry() {
			synchronized (DNavigableMap.this) {
				final K key = firstKey();

				if (key == null) {
					return null;
				}

				final V value = DNavigableMap.this.remove(key);

				return new DEntry(() -> key, () -> value, null);
			}
		}

		/**
		 * last key
		 */
		@Nullable Node lastNode() {
			if (this.backwards) {
				if (this.headmap) {
					return DNavigableMap.this.firstNode();
				} else if (this.min_inclusive) {
					return floorNode(this.min);
				} else {
					return lowerNode(this.min);
				}
			} else {
				if (this.tailmap) {
					return DNavigableMap.this.lastNode();
				} else if (this.max_inclusive) {
					return floorNode(this.max);
				} else {
					return lowerNode(this.max);
				}
			}
		}

		@Override public Entry<K, V> lastEntry() {
			return nodeToEntry(lastNode());
		}

		@Override public K lastKey() {
			return nodeToKey(lastNode());
		}

		@Override public Entry<K, V> pollLastEntry() {
			synchronized (DNavigableMap.this) {
				final K key = lastKey();

				if (key == null) {
					return null;
				}

				final V value = DNavigableMap.this.remove(key);

				return new DEntry(() -> key, () -> value, null);
			}
		}

		@Override public V getOrDefault(final Object key, final V defaultValue) {
			synchronized (DNavigableMap.this) {
				return super.getOrDefault(key, defaultValue);
			}
		}

		@Override public V putIfAbsent(final K key, final V value) {
			synchronized (DNavigableMap.this) {
				return super.putIfAbsent(key, value);
			}
		}

		@Override public boolean remove(final Object key, final Object value) {
			synchronized (DNavigableMap.this) {
				return super.remove(key, value);
			}
		}

		@Override public boolean replace(final K key, final V oldValue, final V newValue) {
			synchronized (DNavigableMap.this) {
				return super.replace(key, oldValue, newValue);
			}
		}

		@Override public V replace(final K key, final V value) {
			synchronized (DNavigableMap.this) {
				return super.replace(key, value);
			}
		}

		@Override public V computeIfAbsent(final K key, final Function<? super K, ? extends V> mappingFunction) {
			synchronized (DNavigableMap.this) {
				return super.computeIfAbsent(key, mappingFunction);
			}
		}

		@Override
		public V computeIfPresent(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
			synchronized (DNavigableMap.this) {
				return super.computeIfPresent(key, remappingFunction);
			}
		}

		@Override public V compute(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
			synchronized (DNavigableMap.this) {
				return super.compute(key, remappingFunction);
			}
		}

		@Override
		public V merge(final K key, final V value, final BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
			synchronized (DNavigableMap.this) {
				return super.merge(key, value, remappingFunction);
			}
		}

		// Navigation

		@Override
		public NavigableMap<K, V> descendingMap() {
			if (this.headmap && this.tailmap) {

				return new SubMapContainer<>(
						DNavigableMap.this, true, null, false, true, null, false, !this.backwards
				);

			} else if (this.headmap) {

				return new SubMapContainer<>(
						DNavigableMap.this, true, null, false, false, this.max, this.max_inclusive, !this.backwards
				);

			} else if (this.tailmap) {

				return new SubMapContainer<>(
						DNavigableMap.this, false, this.min, this.min_inclusive, true, null, false, !this.backwards
				);

			} else {

				return new SubMapContainer<>(
						DNavigableMap.this, false, this.min, this.min_inclusive, false, this.max, this.max_inclusive,
						!this.backwards
				);
			}
		}

		private void lowerBoundCheck(final K fromKey, final boolean fromInclusive) {
			final int compare = compare(this.min, fromKey);

			if (compare > 0 || (compare == 0 && !this.min_inclusive && fromInclusive)) {
				throw new IllegalArgumentException("fromKey less than current lower bound");
			}
		}

		private void upperBoundCheck(final K toKey, final boolean toInclusive) {
			final int compare = compare(this.max, toKey);

			if (compare < 0 || (compare == 0 && !this.max_inclusive && toInclusive)) {
				throw new IllegalArgumentException("toKey greater than current upper bound");
			}
		}

		@Override
		public NavigableMap<K, V> subMap(
				final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive
		) {
			if (this.headmap && this.tailmap) {

				if (this.backwards) {
					return new SubMapContainer<>(
							DNavigableMap.this, false, toKey, toInclusive, false, fromKey, fromInclusive, this.backwards
					);
				} else {
					return new SubMapContainer<>(
							DNavigableMap.this, false, fromKey, fromInclusive, false, toKey, toInclusive, this.backwards
					);
				}

			} else if (this.headmap) {

				if (this.backwards) {
					upperBoundCheck(fromKey, fromInclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, toKey, toInclusive, false, fromKey, fromInclusive, this.backwards
					);
				} else {
					upperBoundCheck(toKey, toInclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, fromKey, fromInclusive, false, toKey, toInclusive, this.backwards
					);
				}

			} else if (this.tailmap) {

				if (this.backwards) {
					lowerBoundCheck(toKey, toInclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, toKey, toInclusive, false, fromKey, fromInclusive, this.backwards
					);
				} else {
					lowerBoundCheck(fromKey, fromInclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, fromKey, fromInclusive, false, toKey, toInclusive, this.backwards
					);
				}

			} else {

				if (this.backwards) {

					lowerBoundCheck(toKey, toInclusive);
					upperBoundCheck(fromKey, fromInclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, toKey, toInclusive, false, fromKey, fromInclusive, this.backwards
					);

				} else {

					lowerBoundCheck(fromKey, fromInclusive);
					upperBoundCheck(toKey, toInclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, fromKey, fromInclusive, false, toKey, toInclusive, this.backwards
					);

				}
			}
		}

		@Override
		public NavigableMap<K, V> headMap(final K toKey, final boolean inclusive) {
			if (this.backwards) {

				if (this.headmap) {

					return new SubMapContainer<>(
							DNavigableMap.this, false, toKey, inclusive, this.tailmap, this.max, this.max_inclusive, this.backwards
					);

				} else {

					lowerBoundCheck(toKey, inclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, toKey, inclusive, this.tailmap, this.max, this.max_inclusive, this.backwards
					);

				}

			} else {

				if (this.tailmap) {

					return new SubMapContainer<>(
							DNavigableMap.this, this.headmap, this.min, this.min_inclusive, false, toKey, inclusive, this.backwards
					);

				} else {

					upperBoundCheck(toKey, inclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, this.headmap, this.min, this.min_inclusive, false, toKey, inclusive, this.backwards
					);
				}
			}
		}

		@Override
		public NavigableMap<K, V> tailMap(final K fromKey, final boolean inclusive) {
			if (this.backwards) {

				if (this.tailmap) {

					return new SubMapContainer<>(
							DNavigableMap.this, this.headmap, this.min, this.min_inclusive, false, fromKey, inclusive, this.backwards
					);

				} else {

					upperBoundCheck(fromKey, inclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, this.headmap, this.min, this.min_inclusive, false, fromKey, inclusive, this.backwards
					);

				}

			} else {

				if (this.headmap) {

					return new SubMapContainer<>(
							DNavigableMap.this, false, fromKey, inclusive, this.tailmap, this.max, this.max_inclusive, this.backwards
					);

				} else {

					lowerBoundCheck(fromKey, inclusive);
					return new SubMapContainer<>(
							DNavigableMap.this, false, fromKey, inclusive, this.tailmap, this.max, this.max_inclusive, this.backwards
					);
				}

			}
		}

		@Override public @NotNull NavigableMap<K, V> subMap(final K fromKey, final K toKey) {
			return subMap(fromKey, true, toKey, false);
		}

		@Override public @NotNull NavigableMap<K, V> headMap(final K toKey) {
			return headMap(toKey, false);
		}

		@Override public @NotNull NavigableMap<K, V> tailMap(final K fromKey) {
			return tailMap(fromKey, true);
		}

		@Override public NavigableSet<K> descendingKeySet() {
			return descendingMap().navigableKeySet();
		}

		@Override public @NotNull NavigableSet<K> keySet() {
			return navigableKeySet();
		}

		@Override public NavigableSet<K> navigableKeySet() {
			return new NavigableSet<K>() {
				@Override public K lower(final K k) {
					return SubMap.this.lowerKey(k);
				}

				@Override public K floor(final K k) {
					return SubMap.this.floorKey(k);
				}

				@Override public K ceiling(final K k) {
					return SubMap.this.ceilingKey(k);
				}

				@Override public K higher(final K k) {
					return SubMap.this.higherKey(k);
				}

				@Override public K pollFirst() {
					final @Nullable Entry<K, V> temp = SubMap.this.pollFirstEntry();
					return temp == null ? null : temp.getKey();
				}

				@Override public K pollLast() {
					final @Nullable Entry<K, V> temp = SubMap.this.pollLastEntry();
					return temp == null ? null : temp.getKey();
				}

				@Override public @NotNull Iterator<K> iterator() {
					final Iterator<Entry<K, V>> it = SubMap.this.entrySet().iterator();

					return new Iterator<K>() {
						@Override public boolean hasNext() {
							return it.hasNext();
						}

						@Override public K next() {
							return it.next().getKey();
						}

						@Override public void remove() {
							it.remove();
						}
					};
				}

				@Override public @NotNull NavigableSet<K> descendingSet() {
					return SubMap.this.descendingKeySet();
				}

				@Override public @NotNull Iterator<K> descendingIterator() {
					return SubMap.this.descendingKeySet().iterator();
				}

				@Override public @NotNull NavigableSet<K> subSet(
						final K fromElement, final boolean fromInclusive, final K toElement, final boolean toInclusive
				) {
					return SubMap.this.subMap(fromElement, fromInclusive, toElement, toInclusive).navigableKeySet();
				}

				@Override public @NotNull NavigableSet<K> headSet(final K toElement, final boolean inclusive) {
					return SubMap.this.headMap(toElement, inclusive).navigableKeySet();
				}

				@Override public @NotNull NavigableSet<K> tailSet(final K fromElement, final boolean inclusive) {
					return SubMap.this.tailMap(fromElement, inclusive).navigableKeySet();
				}

				@Override public @NotNull NavigableSet<K> subSet(final K fromElement, final K toElement) {
					return SubMap.this.subMap(fromElement, toElement).navigableKeySet();
				}

				@Override public @NotNull NavigableSet<K> headSet(final K toElement) {
					return SubMap.this.headMap(toElement).navigableKeySet();
				}

				@Override public @NotNull NavigableSet<K> tailSet(final K fromElement) {
					return SubMap.this.tailMap(fromElement).navigableKeySet();
				}

				@Override public @Nullable Comparator<? super K> comparator() {
					return SubMap.this.comparator();
				}

				@Override public K first() {
					return SubMap.this.firstKey();
				}

				@Override public K last() {
					return SubMap.this.lastKey();
				}

				@Override public int size() {
					return SubMap.this.size();
				}

				@Override public boolean isEmpty() {
					return SubMap.this.isEmpty();
				}

				@Override public boolean contains(final Object o) {
					return SubMap.this.containsKey(o);
				}

				@Override public @NotNull Object[] toArray() {
					return SubMap.this.navigableKeySet().toArray();
				}

				@SuppressWarnings("SuspiciousToArrayCall")
				@Override public @NotNull <T> T[] toArray(final @NotNull T[] a) {
					return SubMap.this.navigableKeySet().toArray(a);
				}

				@Override public boolean add(final K k) {
					throw new UnsupportedOperationException();
				}

				@Override public boolean remove(final Object o) {
					return SubMap.this.remove(o) != null;
				}

				@Override public boolean containsAll(final @NotNull Collection<?> c) {
					return SubMap.this.navigableKeySet().containsAll(c);
				}

				@Override public boolean addAll(final @NotNull Collection<? extends K> c) {
					throw new UnsupportedOperationException();
				}

				@Override public boolean retainAll(final @NotNull Collection<?> c) {
					return SubMap.this.navigableKeySet().retainAll(c);
				}

				@Override public boolean removeAll(final @NotNull Collection<?> c) {
					return SubMap.this.navigableKeySet().removeAll(c);
				}

				@Override public void clear() {
					SubMap.this.clear();
				}
			};
		}
	}

	private @Nullable SubMap whole_map = null;

	private SubMap getWholeMap() {
		if (this.whole_map == null) {
			this.whole_map = new SubMap(true, null, false, true, null, false, false);
		}
		return this.whole_map;
	}

	@Override
	public @NotNull Set<Entry<K, V>> entrySet() {
		return getWholeMap().entrySet();
	}

	@Override public NavigableMap<K, V> descendingMap() {
		return getWholeMap().descendingMap();
	}

	@Override public @NotNull NavigableSet<K> keySet() {
		return navigableKeySet();
	}

	@Override public NavigableSet<K> navigableKeySet() {
		return getWholeMap().navigableKeySet();
	}

	@Override public NavigableSet<K> descendingKeySet() {
		return getWholeMap().descendingKeySet();
	}

	@Override
	public NavigableMap<K, V> subMap(
			final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive
	) {
		return getWholeMap().subMap(fromKey, fromInclusive, toKey, toInclusive);
	}

	@Override public NavigableMap<K, V> headMap(final K toKey, final boolean inclusive) {
		return getWholeMap().headMap(toKey, inclusive);
	}

	@Override public NavigableMap<K, V> tailMap(final K fromKey, final boolean inclusive) {
		return getWholeMap().tailMap(fromKey, inclusive);
	}

	@Override public @NotNull NavigableMap<K, V> subMap(final K fromKey, final K toKey) {
		return getWholeMap().subMap(fromKey, toKey);
	}

	@Override public @NotNull NavigableMap<K, V> headMap(final K toKey) {
		return getWholeMap().headMap(toKey);
	}

	@Override public @NotNull NavigableMap<K, V> tailMap(final K fromKey) {
		return getWholeMap().tailMap(fromKey);
	}

	// sync

	@Override public synchronized int size() {
		return super.size();
	}

	@Override public synchronized boolean isEmpty() {
		return super.isEmpty();
	}

	@Override public synchronized boolean containsValue(final Object value) {
		return super.containsValue(value);
	}

	@Override public synchronized void putAll(final @NotNull Map<? extends K, ? extends V> m) {
		super.putAll(m);
	}

	@Override public synchronized void clear() {
		super.clear();
	}

	@Override public synchronized @NotNull Collection<V> values() {
		return super.values();
	}

	@Override public synchronized void forEach(final BiConsumer<? super K, ? super V> action) {
		super.forEach(action);
	}

	@Override public synchronized void replaceAll(final BiFunction<? super K, ? super V, ? extends V> function) {
		super.replaceAll(function);
	}

	@Override public synchronized V getOrDefault(final Object key, final V defaultValue) {
		return super.getOrDefault(key, defaultValue);
	}

	@Override public synchronized V putIfAbsent(final K key, final V value) {
		return super.putIfAbsent(key, value);
	}

	@Override public synchronized boolean remove(final Object key, final Object value) {
		return super.remove(key, value);
	}

	@Override public synchronized boolean replace(final K key, final V oldValue, final V newValue) {
		return super.replace(key, oldValue, newValue);
	}

	@Override public synchronized V replace(final K key, final V value) {
		return super.replace(key, value);
	}

	@Override
	public synchronized V computeIfAbsent(final K key, final Function<? super K, ? extends V> mappingFunction) {
		return super.computeIfAbsent(key, mappingFunction);
	}

	@Override
	public synchronized V computeIfPresent(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		return super.computeIfPresent(key, remappingFunction);
	}

	@Override
	public synchronized V compute(final K key, final BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		return super.compute(key, remappingFunction);
	}

	@Override
	public synchronized V merge(final K key, final V value, final BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
		return super.merge(key, value, remappingFunction);
	}

	/////////////////
	// DEBUG STUFF //
	/////////////////

	/**
	 * <h1>This method should only be called when debugging DNavigableMap itself</h1>
	 *
	 * <p>Performs basic strictly-increasing checks on the graph.</p>
	 *
	 * <p>This could be more comprehensive, but it worked for what I needed it to do when writing this class.</p>
	 */
	public void integrityCheck() {
		if (!Distortion.DEBUG) {
			throw new IllegalStateException("Not in debug mode");
		}

		// head check
		final Head head = new Head();

		for (byte i = 1; i < head.getHeight(); i++) {
			if (head.getPointer((byte) (i - 1)) == -1 || head.getPointer(i) == -1) {
				throw new IllegalStateException();
			}

			final Node prev = new Node(head.getPointer((byte) (i - 1)));
			final Node curr = new Node(head.getPointer(i));

			if (compare(prev.getKey(), curr.getKey()) == 1) {
				throw new IllegalStateException();
			}
		}

		// forward pointer chasing
		for (byte i = 0; i < head.getHeight(); i++) {
			int a = head.getPointer(i);

			if (a == NULL) {
				continue;
			}

			int b = new Node(a).getPointer(i);

			while (b != NULL) {
				final Node prev = new Node(a);
				final Node curr = new Node(b);

				if (compare(prev.getKey(), curr.getKey()) == 1) {
					throw new IllegalStateException();
				}

				// node checking at layer 0
				if (i == 0) {
					readAll(prev);
					final int[] pointers = prev.pointers;
					boolean hitnull = false;

					for (final int pointer : pointers) {
						if (pointer == NULL) {
							hitnull = true;
						} else if (hitnull) {
							throw new IllegalStateException();
						}
					}
				}

				a = b;
				b = curr.getPointer(i);
			}
		}
	}

	/**
	 * <h1>This method should only be called when debugging DNavigableMap itself</h1>
	 *
	 * <p>This function reconstructs the graph from the raw KV so you can easily find pointer errors without poking into
	 * the state of the class itself.</p>
	 */
	public List<Pair> debugDump() {
		if (!Distortion.DEBUG) {
			throw new IllegalStateException("Not in debug mode");
		}

		final Map<ByteArray, ArrayWrapper> map = ((DebugKV) this.kv).map;

		return map.entrySet().stream()
				.filter(e -> e.getKey().length() == 4)
				.map(e -> {
					final int key = this.util.new IntUnion(e.getKey()).getInt();

					@Nullable PointerList value;
					if (key >= 0) {
						value = new Node(key);
					} else if (key == HEAD) {
						value = new Head();
					} else {
						value = null;
					}

					if (value != null) readAll(value);

					return new Pair(key, value);
				})
				.sorted((p1, p2) -> Integer.compare((int) p1.a, (int) p2.a))
				.collect(Collectors.toList());
	}

	private static void readAll(final PointerList pl) {
		for (byte i = 0; i < pl.getHeight(); i++) {
			pl.getPointer(i);
		}
	}

	public static class Pair {
		public final Object a;
		public final Object b;

		public Pair(final Object a, final Object b) {
			this.a = a;
			this.b = b;
		}

		public String toString() {
			return Objects.toString(this.a) + " => " + Objects.toString(this.b);
		}
	}

}
